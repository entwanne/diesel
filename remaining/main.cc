#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "ast.hh"
#include "parser.hh"

using namespace std;

extern void yyparse();
extern int yydebug;
int assembler_trace = 0;
int print_ast = 0;
int print_quads = 0;
int no_typecheck = 0;
int no_optimize = 0;
int no_quads = 0;
int no_assembler = 0;

void usage(const char *program_name) {
    cerr << "Usage:\n"
	 << program_name << " [-acdfpqsty] inputfile\n"
	 << program_name << " [-h?]\n"
	 << "Options:\n"
	 << "  -h, -?            Shows this message.\n"
	 << "  -a                Print AST (abstract syntax tree).\n"
	 << "  -c                Disable type checking.\n"
	 << "  -d                Turn on parser debugging.\n"
	 << "  -f                Don't optimize.\n"
	 << "  -p                Don't generate quads.\n"
	 << "  -q                Print quad lists.\n"
	 << "  -s                Don't generate assembler code.\n"
	 << "  -t                Include trace printouts in assembler code.\n"
	 << "  -y                Print symbol table.\n";    
    exit(1);
}
    

int main(int argc, char **argv) {
    const char *options = "acdfpqstyh?";
    int option;
    int print_symtab = 0;
    
    extern  FILE *yyin;
    
    opterr = 0;
    optopt = '?';
    
    // Check for options.
    while((option = getopt(argc, argv, options)) != EOF) {
	switch(option) {
	    case 'a':
		cout << "An AST will be printed for each block.\n" << flush;
		print_ast = 1;
		break;
	    case 'c':
		cout << "No type checking will be performed.\n" << flush;
		no_typecheck = 1;
		break;
	    case 'd':
		cout << "Bison debugging turned on.\n" << flush;
		yydebug = 1;
		break;
	    case 'f':
		cout << "No optimization will be done.\n" << flush;
		no_optimize = 1;
		break;
	    case 'p':
		cout << "No quads will be generated.\n" << flush;
		no_quads = 1;
		break;
	    case 'q':
		cout << "A quad list will be printed for each block.\n"
		     << flush;
		print_quads = 1;
		break;
	    case 's':
		cout << "No assembler code will be generated.\n" << flush;
		no_assembler = 1;
		break;
	    case 't':
		cout << "Assembler code will contain quad labels.\n" << flush;
		assembler_trace = 1;
		break;
	    case 'y':
		cout << "Symbol table will be printed after compilation.\n";
		print_symtab = 1;
		break;
	    case 'h':
	    case '?':
		usage(argv[0]);
		break;
	    default:
		break;
	}
    }

    if(optind > argc || optind < argc-1) {
	usage(argv[0]);
    } else if(optind == argc) {
	yyin = stdin;
    } else {
	yyin = fopen(argv[optind], "r");
	if(yyin == NULL) {
	    perror(argv[optind]);
	    exit(1);
	}
    }

    // Start the compilation. This is where all the magic is done.
    // This function resides in parser.cc, which is generated by bison from
    // parser.y.
    yyparse();

    // If given the appropriate flag, prints the symbol table after the input
    // has been parsed.
    if(print_symtab) {
	sym_tab->print(2);
	sym_tab->print(1);
    }
    
    exit(0);
}
    
    
    
